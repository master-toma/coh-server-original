#include "textparser.h"

//#ifed-out include to fool incredibuild dependencies
#if 0
#include "c:\game\code\CoH\Game\..\Common\group\groupMetaMinimap.h"
#endif



//auto-generated staticdefine for enum ArchitectMapType
//autogeneratednocheckin
StaticDefineInt ArchitectMapTypeEnum[] =
{
	DEFINE_INT
	{ "FLOOR", ARCHITECT_MAP_TYPE_FLOOR},
	{ "ITEMS", ARCHITECT_MAP_TYPE_ITEMS},
	{ "SPAWNS", ARCHITECT_MAP_TYPE_SPAWNS},
	{ "COUNT", ARCHITECT_MAP_TYPE_COUNT},
	DEFINE_END
};



//auto-generated staticdefine for enum ArchitectMapColors
//autogeneratednocheckin
StaticDefineInt ArchitectMapColorsEnum[] =
{
	DEFINE_INT
	{ "WHITE", ARCHITECT_COLOR_WHITE},
	{ "GREEN", ARCHITECT_COLOR_GREEN},
	{ "BLUE", ARCHITECT_COLOR_BLUE},
	{ "RED", ARCHITECT_COLOR_RED},
	{ "RGBA", ARCHITECT_COLOR_RGBA},
	{ "COUNT", ARCHITECT_COLOR_COUNT},
	DEFINE_END
};

//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ArchitectMapComponentPlace
ParseTable parse_ArchitectMapComponentPlace[] =
{
	{ "ArchitectMapComponentPlace", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ArchitectMapComponentPlace), 0, NULL, 0 },
	{ "X",							TOK_F32(ArchitectMapComponentPlace, x, 0), NULL },
	{ "Y",							TOK_F32(ArchitectMapComponentPlace, y, 0), NULL },
	{ "Z",							TOK_F32(ArchitectMapComponentPlace, z, 0), NULL },
	{ "XScale",						TOK_F32(ArchitectMapComponentPlace, scX, 0), NULL },
	{ "YScale",						TOK_F32(ArchitectMapComponentPlace, scY, 0), NULL },
	{ "Angle",						TOK_F32(ArchitectMapComponentPlace, angle, 0), NULL },
	{ "Color",						TOK_AUTOINT(ArchitectMapComponentPlace, color, 0), NULL },
	{ "TextBackgroundColor",		TOK_AUTOINT(ArchitectMapComponentPlace, color2, 0), NULL },
	{ "Additive",					TOK_BIT, 0, 8, NULL},
	{ "End",						TOK_END, 0 },
	{ "", 0, 0 }
};

void FindAutoStructBitField(char *pStruct, int iStructSize, ParseTable *pTPI, int iColumn);

int autoStruct_fixup_ArchitectMapComponentPlace()
{
	int iSize = sizeof(ArchitectMapComponentPlace);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfoExplicitly(parse_ArchitectMapComponentPlace, iSize, "ArchitectMapComponentPlace", NULL, "groupMetaMinimap.h");
	{
		ArchitectMapComponentPlace temp;
		memset(&temp, 0, iSize);

		temp.additive = 1;
		FindAutoStructBitField((char*)&temp, iSize, parse_ArchitectMapComponentPlace, 9);
		temp.additive = 0;

	}
	return 0;
};

//autogeneratednocheckin
extern ParseTable parse_ArchitectMapComponentPlace[];
//Structparser.exe autogenerated ParseTable for struct ArchitectMapComponent
ParseTable parse_ArchitectMapComponent[] =
{
	{ "ArchitectMapComponent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ArchitectMapComponent), 0, NULL, 0 },
	{ "MapImage",				TOK_STRING(ArchitectMapComponent, name, 0), NULL },
	{ "TextNotImage",			TOK_AUTOINT(ArchitectMapComponent, isText, 0), NULL },
	{ "defaultXScale",			TOK_F32(ArchitectMapComponent, defaultScX, 0), NULL },
	{ "defaultYScale",			TOK_F32(ArchitectMapComponent, defaultScY, 0), NULL },
	{ "ImageLocation",			TOK_STRUCT(ArchitectMapComponent, places, parse_ArchitectMapComponentPlace) },
	{ "End",					TOK_END, 0 },
	{ "", 0, 0 }
};

int autoStruct_fixup_ArchitectMapComponent()
{
	int iSize = sizeof(ArchitectMapComponent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfoExplicitly(parse_ArchitectMapComponent, iSize, "ArchitectMapComponent", NULL, "groupMetaMinimap.h");
	return 0;
};

//autogeneratednocheckin
extern ParseTable parse_ArchitectMapComponent[];
//Structparser.exe autogenerated ParseTable for struct ArchitectMapSubMap
ParseTable parse_ArchitectMapSubMap[] =
{
	{ "ArchitectMapSubMap", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ArchitectMapSubMap), 0, NULL, 0 },
	{ "Floor",				TOK_AUTOINT(ArchitectMapSubMap, id, 0), NULL },
	{ "defaultXScale",		TOK_F32(ArchitectMapSubMap, defaultScX, 0), NULL },
	{ "defaultYScale",		TOK_F32(ArchitectMapSubMap, defaultScY, 0), NULL },
	{ "MapImage",			TOK_STRUCT(ArchitectMapSubMap, components, parse_ArchitectMapComponent) },
	{ "End",				TOK_END, 0 },
	{ "", 0, 0 }
};

int autoStruct_fixup_ArchitectMapSubMap()
{
	int iSize = sizeof(ArchitectMapSubMap);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfoExplicitly(parse_ArchitectMapSubMap, iSize, "ArchitectMapSubMap", NULL, "groupMetaMinimap.h");
	return 0;
};

//autogeneratednocheckin
extern ParseTable parse_ArchitectMapSubMap[];
extern ParseTable parse_ArchitectMapSubMap[];
extern ParseTable parse_ArchitectMapSubMap[];
//Structparser.exe autogenerated ParseTable for struct ArchitectMapHeader
ParseTable parse_ArchitectMapHeader[] =
{
	{ "ArchitectMapHeader", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ArchitectMapHeader), 0, NULL, 0 },
	{ "{",					TOK_START, 0 },
	{ "Map",				TOK_STRING(ArchitectMapHeader, mapName, 0), NULL },
	{ "FloorMap",			TOK_STRUCT(ArchitectMapHeader, mapFloors, parse_ArchitectMapSubMap) },
	{ "ItemMap",			TOK_STRUCT(ArchitectMapHeader, mapItems, parse_ArchitectMapSubMap) },
	{ "SpawnMap",			TOK_STRUCT(ArchitectMapHeader, mapSpawns, parse_ArchitectMapSubMap) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};

int autoStruct_fixup_ArchitectMapHeader()
{
	int iSize = sizeof(ArchitectMapHeader);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfoExplicitly(parse_ArchitectMapHeader, iSize, "ArchitectMapHeader", NULL, "groupMetaMinimap.h");
	return 0;
};

